# checkm8-a5 Exploit Technical Details

This document provides an in-depth technical explanation of the checkm8 exploit as implemented for Apple A5/A5X SoCs.

## Table of Contents

1. [Overview](#overview)
2. [Vulnerability Background](#vulnerability-background)
3. [A5/A5X-Specific Differences](#a5a5x-specific-differences)
4. [Exploit Stages](#exploit-stages)
5. [Memory Layout](#memory-layout)
6. [Payload Structure](#payload-structure)
7. [Why Arduino?](#why-arduino)
8. [Limitations](#limitations)

---

## Overview

The checkm8 exploit is a bootrom vulnerability affecting Apple devices from iPhone 4S to iPhone X. This implementation specifically targets A5/A5X SoCs (S5L8940X, S5L8942X, S5L8945X) which have unique characteristics requiring a different exploitation approach than newer SoCs.

### Key Characteristics

- **Bootrom vulnerability**: Cannot be patched via software updates
- **Permanent**: Affects device at hardware level
- **DFU mode required**: Exploit runs in Device Firmware Update mode
- **USB-based**: Exploits USB DFU implementation
- **Heap manipulation**: Uses controlled heap allocations

---

## Vulnerability Background

### The Core Vulnerability

The checkm8 exploit targets a use-after-free vulnerability in the USB DFU implementation of Apple's BootROM. The vulnerability exists in how the bootrom handles USB control transfers and manages heap memory.

**Vulnerable code path:**
1. USB control request allocates I/O buffer on heap
2. Request handler is called
3. If handler returns 0, buffer is freed
4. Global state still points to freed buffer
5. Subsequent operations can write to freed memory

### Why It Works

The bootrom's USB stack has several design issues:

1. **Insufficient validation** of control transfer parameters
2. **Predictable heap layout** allowing controlled allocations
3. **Reusable freed memory** without proper cleanup
4. **Callback pointers** stored in heap-allocated structures

---

## A5/A5X-Specific Differences

Unlike newer SoCs (A7+), A5/A5X devices process USB requests differently:

### 1. HOST2DEVICE Request Processing

**Newer SoCs (A7+):**
```c
if (request_handler_ret >= 1) {
    ep0_data_phase_length = request_handler_ret;
    ep0_data_phase_if_num = intf_num;
} else if (request_handler_ret == 0) {
    usb_core_send_zlp();  // Don't touch global state
}
```

**A5/A5X SoCs:**
```c
// Always touches global state, even when ret == 0
ep0_data_phase_length = request_handler_ret;
ep0_data_phase_if_num = v29;
*data_phase = 1;
```

**Impact:** On A5/A5X, any HOST2DEVICE request without data phase resets `ep0_data_phase_length` to zero, requiring a different exploitation sequence.

### 2. Zero-Length Packet Processing

**Newer SoCs:**
```c
if (!data_rcvd) return;  // Skip processing for ZLP
```

**A5/A5X:**
```c
// Processes ZLP same as non-zero packets
end_of_transfer = data_received != 0x40;
if (end_of_transfer) {
    // Resets global state
    goto reset_global_state;
}
```

**Impact:** Standard USB stacks send zero-length packets in status phase, which would reset our carefully crafted global state. This is why we need Arduino with low-level USB control.

---

## Exploit Stages

### Stage 0: Initialization

**Purpose:** Prepare system and verify device

**Actions:**
1. Initialize USB Host Shield
2. Detect device in DFU mode
3. Verify Apple VID/PID (0x05AC:0x1227)
4. Get serial descriptor index
5. Perform pre-exploit validation

**Key Code:**
```cpp
Usb.getDevDescr(0, 0, 0x12, (uint8_t*)&desc_buf);
if(desc_buf.idVendor == APPLE_VENDOR_ID && 
   desc_buf.idProduct == APPLE_DFU_PRODUCT_ID) {
    serial_idx = desc_buf.iSerialNumber;
}
```

### Stage 1: Heap Feng Shui

**Purpose:** Manipulate heap layout to create exploitable conditions

**Technique:** Controlled heap spraying through USB descriptor requests

**Process:**
1. **Stall endpoint** to trigger error handling:
   ```cpp
   ctrlReq(0, 0, 2, DFU_REQUEST_GETSTATUS, ...)
   ```

2. **Spray heap** with 620 allocations of 0x80 bytes:
   ```cpp
   for(int i = 0; i < 620; i++) {
       ctrlReq_SETUP(..., 0x80);  // Request 128-byte descriptor
       dispatchPkt(tokIN, ...);    // Read response
   }
   ```

3. **Final allocation** of 0x81 bytes to complete layout:
   ```cpp
   ctrlReq_SETUP(..., 0x81);
   ```

**Why 620 iterations?**
- Empirically determined value
- Creates specific heap fragmentation pattern
- Ensures reliable memory layout across devices
- Positions allocations for subsequent stages

**Memory state after Stage 1:**
```
Heap Layout:
[0x80 alloc][0x80 alloc]...[0x80 alloc][0x81 alloc]
                                         ^
                                         Target for overwrite
```

### Stage 2: Set Global State

**Purpose:** Set up global USB state for exploitation

**Technique:** Exploit HOST2DEVICE request handling difference

**Process:**

1. **Send DFU_DNLOAD with data:**
   ```cpp
   ctrlReq_SETUP(DFU_DNLOAD, wLength=0x40);
   sendOut(data, 0x40);  // Pre-packet
   sendOut(data, 0x40);  // Data packet
   dispatchPkt(tokINHS); // Handshake
   ```

2. **Send zero-length packet:**
   ```cpp
   ctrlReq(DFU_DNLOAD, wLength=0);
   ```
   On A5/A5X, this doesn't reset global state like newer SoCs

3. **Get status twice:**
   ```cpp
   ctrlReq(DFU_GETSTATUS, ...);  // First call
   ctrlReq(DFU_GETSTATUS, ...);  // Second call
   ```
   Required to transition DFU state machine

4. **Send incomplete transfer:**
   ```cpp
   ctrlReq_SETUP(DFU_DNLOAD, wLength=padding+0x40);
   for(each packet) {
       sendOut(packet, 0x40);
   }
   // Don't send status phase - leave incomplete
   ```

5. **Trigger USB reset:**
   ```cpp
   Usb.setUsbTaskState(USB_ATTACHED_SUBSTATE_RESET_DEVICE);
   ```

**Result:** Global state now points to freed I/O buffer, ready for overwrite

**Global State After Stage 2:**
```
ep0_data_phase_buffer = <freed buffer address>
ep0_data_phase_length = padding + 0x40
ep0_data_phase_rcvd = 0
```

### Stage 3: Heap Occupation

**Purpose:** Overwrite freed memory and deliver payload

**Technique:** Controlled writes to freed buffer

**Process:**

1. **Trigger heap occupation:**
   ```cpp
   ctrlReq_SETUP(GET_DESCRIPTOR, serial_idx, 0x81);
   dispatchPkt(tokIN);
   ```

2. **Send overwrite data:**
   ```cpp
   ctrlReq_SETUP(0, 0, 0, 0, wLength=0x40);
   sendOut(pre_packet, 0x40);
   sendOut(overwrite, 0x40);  // Overwrites callback pointer
   ```

3. **Deliver ARM shellcode:**
   ```cpp
   ctrlReq_SETUP(DFU_DNLOAD, wLength=sizeof(payload));
   sendOut(pre_packet, 0x40);
   for(each chunk) {
       sendOut(payload_chunk, 0x40);
   }
   ```

4. **Trigger execution:**
   - USB reset triggers callback
   - Callback pointer now points to our payload
   - Payload executes in bootrom context

**Overwrite Structure:**
```c
struct overwrite {
    uint32_t padding[12];      // Align to callback pointer
    uint32_t callback_addr;    // Points to our payload (0x34000000)
    uint32_t padding2[2];
};
```

---

## Memory Layout

### Heap Structure

```
Before Exploitation:
┌─────────────────────────────────────┐
│  Bootrom Heap (grows upward)       │
│                                     │
│  [Normal allocations]               │
│  [USB buffers]                      │
│  [DFU state]                        │
└─────────────────────────────────────┘

After Heap Feng Shui:
┌─────────────────────────────────────┐
│  [0x80][0x80]...[0x80][0x81]       │
│                         ↑            │
│                    Target buffer    │
└─────────────────────────────────────┘

After Global State Setup:
┌─────────────────────────────────────┐
│  [0x80][0x80]...[FREED][0x81]      │
│                   ↑                  │
│         ep0_data_phase_buffer       │
└─────────────────────────────────────┘

After Heap Occupation:
┌─────────────────────────────────────┐
│  [0x80][0x80]...[PAYLOAD][0x81]    │
│                   ↑                  │
│              Our shellcode          │
└─────────────────────────────────────┘
```

### Address Space

```
BootROM:     0x00000000 - 0x00010000  (64KB)
SRAM:        0x22000000 - 0x22040000  (256KB)
Payload:     0x34000000  (Loaded here)
Stack:       0x22040000  (Top of SRAM)
```

---

## Payload Structure

### Overwrite Payload

```c
const uint8_t overwrite[] = {
    0x08, 0x00, 0x00, 0x00,  // Padding
    0x02, 0x00, 0x00, 0x00,  // Padding
    // ... more padding ...
    0x00, 0x00, 0x00, 0x34,  // Callback address (0x34000000)
    0x00, 0x00, 0x00, 0x00,  // Padding
    0x00, 0x00, 0x00, 0x00   // Padding
};
```

### ARM Shellcode Payload

The payload is ARM assembly code that:

1. **Demotes the device:**
   ```assembly
   ; Enable SWD debugging
   ; Modify security settings
   ; Set development KBAG flag
   ```

2. **Prints success message:**
   ```assembly
   ; Output "PWND:[checkm8]" via USB
   ```

3. **Returns to DFU mode:**
   ```assembly
   ; Clean up and return control
   ```

**Payload characteristics:**
- Position-independent code
- Thumb-2 instruction set
- ~480 bytes total
- SoC-specific addresses

---

## Why Arduino?

### The Problem with Standard USB Stacks

Standard operating system USB stacks automatically send:

1. **SET_ADDRESS** - Assigns USB address
2. **GET_DESCRIPTOR** - Reads device descriptors
3. **SET_CONFIGURATION** - Configures device
4. **Zero-length packets** - Status phase of transfers

These automatic operations interfere with exploitation by:
- Resetting global state prematurely
- Triggering unwanted heap allocations
- Sending zero-length packets that reset state on A5/A5X

### Arduino + MAX3421E Solution

**Advantages:**

1. **Low-level control:**
   - Direct register access
   - Manual packet construction
   - Precise timing control

2. **No automatic requests:**
   - We control every USB transaction
   - Can skip status phases
   - Can send incomplete transfers

3. **Predictable behavior:**
   - No OS interference
   - Deterministic timing
   - Reliable exploitation

**MAX3421E Features:**
- SPI-controlled USB host
- Register-level access
- Manual packet dispatch
- Perfect for exploitation

---

## Limitations

### Device Limitations

1. **A5/A5X only:**
   - iPhone 4S
   - iPad 2 (all variants)
   - iPad Mini (1st gen)
   - Apple TV 3

2. **DFU mode required:**
   - Device must be in DFU mode
   - Cannot exploit from normal mode
   - User must manually enter DFU

3. **Permanent demotion:**
   - Device is demoted after exploit
   - Uses development KBAG
   - Cannot be undone at bootrom level

### Hardware Limitations

1. **USB cable quality:**
   - Must be direct connection
   - No embedded USB hubs
   - Good quality data cable required

2. **Power requirements:**
   - Device battery >50% recommended
   - Stable power supply needed
   - USB power may be insufficient

3. **Timing sensitivity:**
   - Exploit requires precise timing
   - May need multiple attempts
   - Environmental factors can affect success

### Software Limitations

1. **No CPID verification:**
   - Cannot automatically detect SoC
   - User must select correct target
   - Wrong selection causes failure

2. **No automatic retry:**
   - Manual reset required on failure
   - No built-in retry logic
   - User must diagnose issues

3. **Limited feedback:**
   - Serial output required for debugging
   - LED provides basic status only
   - No detailed error analysis

---

## Security Implications

### What This Exploit Enables

1. **Bootrom code execution:**
   - Run arbitrary code in bootrom context
   - Highest privilege level
   - Before any security checks

2. **Device demotion:**
   - Enables SWD debugging
   - Uses development KBAG
   - Affects firmware decryption

3. **Research capabilities:**
   - Firmware analysis
   - Security research
   - Jailbreak development

### What This Exploit Does NOT Enable

1. **Remote exploitation:**
   - Requires physical access
   - Requires DFU mode entry
   - Cannot be done remotely

2. **Persistent jailbreak:**
   - Exploit is not a jailbreak
   - Additional tools needed
   - Must be re-run after reboot

3. **Data access:**
   - Does not bypass encryption
   - Does not access user data
   - Does not break passcode

---

## References

### Original Research

- **checkm8 by axi0mX:** https://github.com/axi0mX/ipwndfu
- **Blackhat presentation:** https://www.blackhat.com/us-19/briefings/schedule/#checkm8-forever-exploit-for-iphone-and-ipad-16806
- **Technical writeup:** https://habr.com/ru/company/dsec/blog/472762/

### A5/A5X-Specific Research

- **littlelailo's algorithm:** https://gist.github.com/littlelailo/42c6a11d31877f98531f6d30444f59c4
- **DSecurity article:** https://habr.com/ru/company/dsec/blog/472762/

### Related Tools

- **ipwndfu:** Python implementation
- **irecovery:** DFU mode interaction
- **img4tool:** Firmware manipulation

---

## Glossary

- **BootROM:** Read-only memory containing device boot code
- **DFU:** Device Firmware Update mode
- **CPID:** Chip ID identifying SoC model
- **KBAG:** Key Bag for firmware decryption
- **SWD:** Serial Wire Debug interface
- **Heap Feng Shui:** Technique for manipulating heap layout
- **Use-After-Free:** Vulnerability where freed memory is reused
- **ZLP:** Zero-Length Packet in USB protocol

---

## Conclusion

The checkm8 exploit for A5/A5X SoCs demonstrates the power of bootrom vulnerabilities and the challenges of exploiting older hardware with unique characteristics. While the exploit is complex, understanding each stage reveals the careful orchestration required to achieve reliable code execution in the bootrom.

The use of Arduino provides the low-level USB control necessary for exploitation, making this a practical implementation for security research and educational purposes.

**Remember:** This exploit permanently demotes devices. Use responsibly and only on devices you own.
